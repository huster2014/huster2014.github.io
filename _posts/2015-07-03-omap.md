---
layout: post
title: ceph osd中omap的实现
---

  FileStore作为ObjectStore最重要的实现之一，封装了OSD底层所有I/O操作。FileStore不仅对外提供Object的读写接口，还提供了对Object属性(xattr)和关联kv(omap)的访问接口。xattr和omap都是与某个Object关联key-value对，在实现上xattr利用文件的xattr属性进行存取，而omap则利用DBObjectMap实现存取。由于文件系统在文件xattr长度上的限制，xattr溢出的部分就会被存放在DBObjectMap中，因而xattr和omap操作是互通，只不过前者的长度受限，而后者没有限制罢了。<br>

### DBObjectMap的0-copy clone 技术
  DBObjectMap对外提供访问xattr和omap的接口：<br>

``` c++
int set_keys(const ghobject_t &oid, const map<string, bufferlist> &set, const SequencerPosition *spos=0);
int set_xattrs(const ghobject_t &oid,  const map<string, bufferlist> &to_set,  const SequencerPosition *spos=0);
int clone(const ghobject_t &oid, const ghobject_t &target, const SequencerPosition *spos); 
``` 

  访问omap和xattr是需要指定相关联的object。从接口可以看到，与某个object相关联的kv对(omap或者xattr)构成了一个与该object向关联的map表。xattr和omap都是kv对的集合，但是xattr适用于用来存储数量较少的kv对，而omap则适用于存储数量加大的kv对，因此在实现clone操作时分别采用不同的方式，对xattr，DBObjectMap采用拷贝的方法，而对omap，DBObjectMap采用稍微复杂一点0-copy的技术。<br>
  
### 0-copy clone的实现
![](/images/omap/clone.png) <br>

  DBObjectMap为每个Object都对应一个header结构体，用来记录分配给Object的序列号seq，Object拥有的kv对将以相应的seq作为前缀存储在leveldb中。当执行clone(src, dst)操作时，DBObjectMap分别为src和dst分配新的序号并创建新的header结构体，将原来src 对应的header结构体作为他们的parent header。当查找某个object的kv对时，以parent header中的序号作为前缀就能在leveldb中查找相应kv对了，这部分操作被封装在DBObjectMap的迭代器中(具体后面会介绍)。<br>
  
### omap的修改和删除
  假设object a克隆前后的序列号分别为seq1和seq2，一旦克隆操作成功之后，以seq1为前缀的kv对就成为只读的。插入或者更新与object a相关联的kv对时，向leveldb中插入的kv对都将与seq2作为前缀。在leveldb中检索kv对时，如果同时存在以seq1和seq2为前缀的kv对，则以seq2为前缀的kv对必然是最新的，因此返回seq2为前缀的kv对即可。<br>
  但是如果要删除与object a相关联的某个kv对呢？假设克隆操作前object a已经存在相应的kv对(以seq1为前缀)，克隆之后对该kv对进行了修改(添加了以seq2为前缀的kv对)，如果此时要删除该kv对，就必须同时删除以seq1和seq2为前缀的kv对，但是以seq1为前缀的kv对是只读的(存在其它的object共享该kv对)，所以按照前面的方式来读取kv对时就会返回错误的结果(以seq1为前缀的kv对)。<br>
  为了解决这个问题，DBObjectMap为每个header结构体关联了一个“complete”表，专门用来处理kv对的删除操作。当删除与object a相关联的kv对(假设key = i)时：<br>
  1. 读取[i,i+20)区间内的所有以seq1为前缀的有效kv对，并将这些kv对重新以seq2为前缀写入到leveldb中<br>
  2. 将key=i，value=i+20的kv对插入到object a的"complete"表中<br>
  3. 合并object a的“complete”表<br>
  由此可见，“complete”表实质上是一个区间表，标识parent在某个区间内的kv对是无效的。当读取与object a关联的kv对时，如果kv以seq1为前缀，且k落在“complete”的某个区间内，则应该返回空值，因为该kv对在克隆操作完成之后已经被删除。<br>

### 迭代器

```cpp
class DBObjectMapIteratorImpl : public ObjectMapIteratorImpl {
 /* 指向父header的迭代器 */
  ceph::shared_ptr<DBObjectMapIteratorImpl> parent_iter;
  /* 指向当前header表的leveldb迭代器指针指向区间表的leveldb迭代器指针 */
  KeyValueDB::Iterator key_iter;
  /* 指向区间表的leveldb迭代器指针 */
  KeyValueDB::Iterator complete_iter;
  /* 指向key_iter和parent_iter中的一个，标识正待访问的kv对 */
  ceph::shared_ptr<ObjectMapIteratorImpl> cur_iter; 
  ...
}
```
![](/images/omap/omap_iter.png) <br>
  DBObjectMapIteratorImpl和KeyValueDB::Iterator都继承自ObjectMapIteratorImpl，它们都实现了value()和next()方法。其中KeyValueDB::Iterator用来从leveldb中遍历有特定前缀的kv
对，而DBObjectMapIteratorImpl在KeyValueDB::Iterator基础上之上实现了对关联于某个object的kv对的遍历。<br>
DBObjectMapIteratorImpl的cur\_iter成员是一个迭代器指针，所指向的迭代器(parent\_iter或者key\_iter)对应当前正在访问的kv对。当调用next()方法调整迭代器时，就会借助cur\_iter自增parent\_iter或者key\_iter，然后比较parent\_iter和key\_iter指向kv对来决定cur\_iter应该指向哪个迭代器。complete\_iter指向前面提到的"complete"区间表，在比较parent\_iter和key\_iter指针时，用来将parent\_iter跳过哪些无效的区间。
