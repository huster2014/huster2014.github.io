---
layout: post
title: ceph osd中omap的实现
---

FileStore作为ObjectStore最重要的实现之一，封装了OSD底层所有I/O操作。FileStore不仅对外提供Object的读写接口，还提供了对Object属性(xattr)和关联kv(omap)的访问接口。xattr和omap都是与某个Object关联key-value对，在实现上xattr利用文件的xattr属性进行存取，而omap则利用DBObjectMap实现存取。由于文件系统在文件xattr长度上的限制，xattr溢出的部分就会被存放在DBObjectMap中，因而xattr和omap操作是互通，只不过前者的长度受限，而后者没有限制罢了。<br>

### DBObjectMap的0-copy clone 技术
DBObjectMap对外提供与Object关联的xattr和omap接口，如set_，get_，rm_以及clone和sync接口。<br>

``` c++
int set_keys(const ghobject_t &oid, const map<string, bufferlist> &set, const SequencerPosition *spos=0);
int set_xattrs(const ghobject_t &oid,  const map<string, bufferlist> &to_set,  const SequencerPosition *spos=0);
int clone(const ghobject_t &oid, const ghobject_t &target, const SequencerPosition *spos); <br>
...
```
从接口来看，Object的xattr和omap只不过是关联与Object多个kv对构成的map。<br>
xattr适合于存储数量较少的kv对，而omap适用于存储数量较多的kv对，因此在实现clone操作时分别采用不同的方式，对xattr，DBObjectMap采用拷贝的方法，对omap，DBObjectMap采用稍微复杂一点0-copy的技术。
#### 0-copy clone的实现
![](/image/omap/clone.png)
DBObjectMap为每个Object都对应一个header结构体，用来记录分配给Object的序列号seq，Object拥有的kv对将以相应的seq作为前缀。<br>
当执行clone(src, dst)操作时，DBObjectMap分别为src和dst object分配新的序号并创建新的header结构体，将原来src object对应的header结构体作为他们的parent header。当查找某个object的kv对时，以parent header中的序号作为前缀就能在leveldb中查找相应kv对了。
