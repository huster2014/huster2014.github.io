---
layout: post
title: ceph osd中omap的实现
---

FileStore作为ObjectStore最重要的实现之一，封装了OSD底层所有I/O操作。FileStore不仅对外提供Object的读写接口，还提供了对Object属性(xattr)和关联kv(omap)的访问接口。xattr和omap都是与某个Object关联key-value对，在实现上xattr利用文件的xattr属性进行存取，而omap则利用DBObjectMap实现存取。由于文件系统在文件xattr长度上的限制，xattr溢出的部分就会被存放在DBObjectMap中，因而xattr和omap操作是互通，只不过前者的长度受限，而后者没有限制罢了。<br>

### DBObjectMap的0-copy clone 技术
DBObjectMap对外提供与Object关联的xattr和omap接口，如set_，get_，rm_以及clone和sync接口。<br>

``` c++
int set_keys(const ghobject_t &oid, const map<string, bufferlist> &set, const SequencerPosition *spos=0);
int set_xattrs(const ghobject_t &oid,  const map<string, bufferlist> &to_set,  const SequencerPosition *spos=0);
int clone(const ghobject_t &oid, const ghobject_t &target, const SequencerPosition *spos); <br>
...
```
从接口来看，Object的xattr和omap只不过是关联与Object多个kv对构成的map。<br>
xattr适合于存储数量较少的kv对，而omap适用于存储数量较多的kv对，因此在实现clone操作时分别采用不同的方式，对xattr，DBObjectMap采用拷贝的方法，对omap，DBObjectMap采用稍微复杂一点0-copy的技术。
#### 0-copy clone的实现
![](/image/omap/clone.png) <br>
DBObjectMap为每个Object都对应一个header结构体，用来记录分配给Object的序列号seq，Object拥有的kv对将以相应的seq作为前缀存储在leveldb中。当执行clone(src, dst)操作时，DBObjectMap分别为src和dst object分配新的序号并创建新的header结构体，将原来src object对应的header结构体作为他们的parent header。当查找某个object的kv对时，以parent header中的序号作为前缀就能在leveldb中查找相应kv对了，这部分操作被封装在DBObjectMap的迭代器中(具体后面会介绍)。
#### omap的修改和删除
一旦对某个object a执行了clone操作，假设object a克隆前后的序列号分别为seq1和seq2，则克隆完成之后以seq1为前缀的kv对就成为只读的。任何对与object a修改都只能反映到以seq2为前缀的kv对中。修改某kv对时，只需以seq2为前缀将kv对插入到leveldb即可，在读取kv对时，如果同时存在seq1和seq2为前缀的记录，说明object a在克隆之后有修改了相应的kv对，所以以seq2为前缀的记录才是最新的。但是在删除某个kv对的时候则不能直接删除了
#### 迭代器
```cpp
class DBObjectMapIteratorImpl : public ObjectMapIteratorImpl {
  ceph::shared_ptr<DBObjectMapIteratorImpl> parent_iter;
  KeyValueDB::Iterator key_iter;
  KeyValueDB::Iterator complete_iter;
  ceph::shared_ptr<ObjectMapIteratorImpl> cur_iter;
```
其中KeyValueDB::Iterator也继承自ObjectMapIteratorImpl，


